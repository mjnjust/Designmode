1、目的：学习各种设计模式

2、编码：utf-8

3、单例模式：Singleton1：懒汉式单例模式  Singleton2饿汉式单例模式 Singleton3 拓展的类，可以限定实例化该类的个数

4、工厂模式：以杯子为例，AbastractCupFactory是杯子工厂的虚拟类，CupFactory是一个可以产生杯子的工厂，ICup是一个杯子的接口，
所有不同类型的杯子都要实现这个接口，杯子有WineCup酒杯,TeaCup茶杯,WaterCup水杯。

5、建造者模式和模板模式：以车子为例，AbstractCar是所有车子的抽象基础类,CarA和CarB是具体的实现类。
	为什么叫建造者模式？
	假设一个产品X有很多的零件，比如有a、b、c、d四个零件，那么制造X的步骤就可以有很多，比如b->b+a->b+a+c->b+a+c+d->X，也可以a->b+a->b+a+c->b+a+c+d->X等等。
	但是这里面abcd四大零件是必须要做的，只是组装的顺序不同，那么这时候就可以使用建造者模式。
	我现在觉得模板模式和建造者模式很像，只是建造者模式可以根据需要制定抽象类中各种方法的执行顺序。
	
6、代理模式
	到目前为止，我觉得代理模式是最有用的模式，在开发的时候可以先考虑做功能，然后再考虑权限什么的问题，这样简直是神奇！
	以做作业为例，DoHomeWork接口中有一个DoHomeWork接口，Student和代理的类都要实现这个接口，HomeWorkProxy是普通代理，HomeWorkProxy2是强制代理，HomeWorkProxy3是动态代理

7、原型模式
	我觉得原型模式本质上就是一个利用clone方法代替new方法来创建新的对象的一种模式
	Ball 就是使用原型模式的类，其实就是实现了一下cloneable接口。最主要的就是要注意深拷贝和浅拷贝的区别。
	
8、中介者模式
	因为类太多了，所以把中介者模式的类放在package2中。
	为了降低类和类之间的耦合度，使用一个中介者类。如果有三个类A、B、C,A和B、C有联系，B和A、C有联系，C和A、B有联系，那么类之间的依赖会很严重，所以引入一个D类，使A利用D来和B、C产生联系。
	ArtillerySoldier炮兵类，FootSoldier步兵类，SpySoldier侦查兵类。Mediator中介者。
	
9、命令模式
	命令模式的类放在package3中
	Command是命令角色的基类，Receiver是执行角色的基类，Invoke是调用者类。

10、责任链模式
	放在package4中
	将命令或者信息在一条处理链上传递，直到有人能处理这个命令或者信息。
	
11、 装饰模式
	放在package5中，同时测试代码也放在package5中，名为DecorateTest
	动态的给一个类加上一些修饰，注意是动态的，我可以随时随地的给一个对象加一些想给它加的方法什么的。我觉得装饰模式的本质是利用父类型引用能指向子类型引用这个原理，给某个类封装一层或多层。
	
12、适配器模式
	
	
		
	
	